---
title: "C++原子操作与无锁队列"
subtitle: " "
layout: post
author: "Tidcl"
header-style: text
hidden: false
plchart: true
tags:
  - C++
  - CAS
  - Queue

---





# 原子操作

在多线程环境下，当多个线程同时访问共享数据时，能够保证数据原子性和同步性的操作。

## 原子性
原子性是啥？在数据库acid中，a就是原子性，但是什么是原子性？
简单举个例
```c++
//此处就拿最常见的new关键字举例
int* iPtr = new int(0);
//new关键字起码会包含三个步骤：
//调用内存分配函数（例如malloc）来分配足够的空间给一个int
//将分配的内存地址存储到iPtr指向的内存位置
//将值0存储到分配的内存地址中，以初始化int
```
linux系统是分时操作系统，因为CFS任务调度原因，一个线程随时都可能被中断，一旦中断触发线程切换，线程的寄存器、局部变量等数据集体入栈。
假如new是一个具有原子性的操作，而在执行new的过程中发生了线程切换，就会导致三个步骤被拆分开。这样指令被拆开的操作就不具有原子性。
### 那么如何保证操作的原子性？
禁止中断触发
只要在指令开始执行前禁止中断触发，运行完指令再启用中断触发，这样就能保证指令的原子性。如何禁止中断触发便不在讨论范围内了。
## 同步性
当多个线程访问原子变量，所有线程在任何时候访问到的变量值都一样。
如果访问的不是原子变量，可能访问到变量的中间状态。
由于目前的cpu中一般都是8核16核的，线程是单独运行在某个核心上的，每个核心都有独立的L1、L2缓存，且cpu操作数据时都是在缓存中进行读写，如果缓存中没有变量才回去内存读取。
### 缓存一致性
```c++
//假如有A、B、C 3个线程在执行过程中访问变量z，可能出现三个线程从内存中将变量z拷贝到自己的独立缓存中进行处理。
char z = 'z';
void threadA(){
    if(z == 'z')
        z = 'a';
}
void threadB(){
    if(z == 'z')
        z = 'b';
}
void threadC(){
    if(z == 'z')
        z = 'c';
}

//假设此时A、B、C线程同时在执行，那么每个核心看到的z可能是不一样的。
//因为线程并不是同步执行的，可能C线程先执行完，此时z应该是c。但是核心的独立缓存，线程A和线程B可能在z为z时就拷入了缓存。此时核心缓存中的z变量都不一致了。
```
### 写回策略
层级关系：
核心
 |
缓存
 |
内存
核心写出数据策略：数据在缓存是否命中，命中直接写，标记脏数据。没有命中，使用LRU算法定位一个缓存块，如果缓存块是脏数据（未写进内存的缓存数据），把脏数据写进内存，再把新数据写入缓存块；
核心读入数据策略：先定位缓存块，如果缓存块是脏数据，先将脏数据写入内存，再将数据从内存读入缓存块中。
写回策略尽量让热数据保存在缓存中，迫不得已再去内存读取。
### 如何保证缓存一致性？
MESI状态机，但是不在本文的讨论范围。

## 内存序
### 为什么需要内存序？
在多处理器系统中，每个处理器可能有自己的缓存，并且这些缓存可能不会立即与主内存同步。内存序确保了在多线程环境中，当一个线程修改了数据后，其他线程能够看到这些修改，从而保证了数据的一致性。
内存序确保线程在执行代码时的顺序，如果不使用内存序，编译器或cpu可以为了优化代码，修改代码的执行顺序。
### 内存序有哪些？
1. memory_order_relaxed 保证原子性，不保证同步性，不限制代码顺序。
3. memory_order_acquire 保证原子性，保证同步性，保证了在获取操作之后对共享数据的所有读取操作都将看到最新的数据，不允许优化该内存序后面的代码顺序。
4. memory_order_release 保证原子性，保证同步性，保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见，不允许优化该内存序前面的代码顺序。
5. memory_order_acq_rel 保证原子性，保证同步性，结合了获取和释放两种内存序的特点。它既保证了获取操作之后对共享数据的所有读取操作都将看到最新的数据，又保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见。
6. memory_order_seq_cst 保证原子性，保证同步性，保证了所有线程都将看到相同的操作顺序，并且所有原子操作都将按照程序顺序执行。

# 队列
1. 数组
直接使用数组来实现队列。
实现简单，访问速度快。
固定大小，不够灵活，且在到达数组末尾时可能需要移动整个队列的元素到新数组。
2. 链表
链表实现队列，每个节点包含数据和指向下一个节点的指针。
动态大小，插入和删除操作效率高，不需要移动其他元素。
随机访问速度慢，且每个节点需要额外的内存来存储指针。
3. 链表+数组
使用一个链表来存储队列中的元素，同时使用数组来提高随机访问的速度。
实现方式较为复杂，需要同时管理链表和数组。
4. 内存块
将一块连续的内存划分为固定大小的块，每个块存储一个元素，通过指针操作来实现队列。
优点是可以实现非常高效的内存使用和快速的元素访问。
缺点是大小固定，不够灵活，且管理内存块需要额外的逻辑。
5. 循环数组
数组实现队列的一种优化方式，使用两个指针分别指向队列的头部和尾部，当到达数组末尾时循环回到数组的开始位置。
空间利用率高，不需要额外的内存分配。
在处理头部和尾部指针时需要特别注意边界条件。

## 有锁队列与无锁队列
有锁队列是通过互斥锁来实现线程安全的数据结构。
无锁队列通过原子操作来确保在多线程环境下的正确性和一致性。

## 队列实现的分析
### ZeroMQ之yqueue
yqueue是ZeroMQ（ZMQ）底层实现的一个高效的无锁队列数据结构，主要用于实现线程安全的消息队列。
#### 动态内存分配
虽然动态内存分配在高性能组件中不是个好词，但是yqueue通过动态内存一次性批量分配元素，提高了效率。
#### chunk_t
chunk_t是yqueue存储元素的内存块，包含一个values数组用来储存元素，通过两个指针prev、next指向前后的chunk块
struct chunk_t
{
    T values[N]; //每个chunk_t可以容纳N个T类型的元素，以后就以一个chunk_t为单位申请内存
    chunk_t *prev;
    chunk_t *next;
};
#### 局部性原理
yqueue中有一个spare_chunk指针，类型为atomic_ptr_t。atomic_ptr_t提供了原子操作，使spare_chunk具有原子性。
spare_chunk来保存最近一次访问分配出来的chunk，刚用完的chunk提高了cache亲和性，提高了缓存效率。

front():
back():
push():
pop():
### Zero之ypipe
#### ypipe与yqueue
ypipe通过yqueue+cas实现了单写单读的无锁队列。
比起yqueue，ypipe有以下区别：
1. yqueue允许多生产者多消费者并发进行入队和出队操作。而ypipe适用于单线程写和单线程读。
2. ypipe和yqueue都通过原子操作实现无锁机制，ypipe还使用了CAS。
3. yqueue不保证数据完整性，数据可能因为写入过快导致数据被覆盖。ypipe允许分批写入数据，只有当数据完全写入读取线程才能进行读取。
4. yqueue适用于需要高并发处理的场景，ypipe适用于需要顺序控制的场景。
5. ypipe新增了w、f、r、c指针

f --- w 构成写入范围
f（写范围的结束位置）
w（写范围的开始位置）

r --- c 构成读取范围
r（读范围的开始位置）
c（）

void write(const T &value_, bool incomplete_):
该函数第二个参数决定是否更新f指针。
bool flush():
首先判断w和f是否相等，相等则表示没有新写入，如果有新写入f会更新。
使用cas判断c指针是否与w相等，相等则将w更新为f，表示还没有读完。c与w不相等表示已经读完了，因为读完后c变为NULL，c更新成f，w也更新为f，表示数据已经写入完成；与w不相等
check_read():
判断r是否为队列头位置，如果不是则表示还有数据返回true，直接读取。
check_read预取：
判断c是否等于队列头，如果不等于，表示可能因为flush导致c更新了；如果等于c表示已经读到尾了，取不出了，设置c为NULL。因为read函数每次pop()都会使front()更靠近c，c只会大于等于front()
判断r是否为队列头部
read():
调用check_read判断是否可读。
调用队列pop函数后，队列的头位置修改。