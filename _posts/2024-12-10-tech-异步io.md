---
title: "异步io"
subtitle: " "
layout: post
author: "Tidcl"
header-style: text
hidden: false
plchart: true
tags:
  - iouring

---



## 异步io

### 异步io基本概念

非阻塞操作，内核处理事件，事件通知。异步io操作时io操作不成为应用程序的瓶颈，在高吞吐和高并发都有不错性能

### 异步io与同步io区别

同步io在使用时，需要应用程序检测事件并对io进行操作，因为cpu执行速度比起磁盘读取数据的速度快太多太多，如果此时应用程序等待数据到达，会浪费cpu的算力。当然现实情况是，内核会将该线程挂起加入等待队列，当磁盘数据到达后从等待队列取出线程恢复执行，即使内核通过线程切换保证了算力不被浪费。但，如果现在有100W个同步io操作，即使用io多路复用检测io事件减少多线程的开销，其浪费在线程切换和数据拷贝带来的性能下降也是不可忽略的，因为io操作实际发生在应用程序线程中。
那么对于线程切换和拷贝带来的开销就没法避免了吗？
异步io解决了应用程序io操作带来的性能问题，异步io通过将io操作转移到内核，应用程序直接处理读写完成的数据，减少了io操作带来的性能下降。

### 异步io好不好？

说了不少异步io的好处，感觉总是在吹牛异步io比同步io多厉害，并没拉踩的意思，毕竟select到现在也有它的应用场景，不过异步io带来的学习成本和对编程人员能力的考验也是不低的。然而在特殊场景下异步io也并非超越了同步io，异步io需要维护数据缓冲区，且异步io操作逻辑都发生在内核中，如果io数量很大导致内核性能降低，相比epoll只对有事件的io处理，此时比起epoll性能都相差无几了。



## iouring

iouring通过两个队列与内核进行通信。