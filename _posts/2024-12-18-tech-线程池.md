---
title: "线程池"
subtitle: " "
layout: post
author: "Tidcl"
header-style: text
hidden: false
plchart: true
tags:
  - 线程池

---



## 线程池是什么？

线程池是池式组件管理多个线程，将任务提交到线程池后，线程池使用线程进行处理。线程池提供了异步处理的能力，能有效降低单个线程的执行压力。通过线程复用，节省了线程创建和释放时的资源消耗。线程池在管理线程的时候，也控制了应用程序的线程数量不至于过多。



## 为什么使用线程池？

在一些需要异步处理的场景，比如带GUI界面的应用程序需要进行网络请求或者磁盘请求，不使用线程池就会导致界面主线程事件循环卡住，导致界面出现无法响应的情况。此时可以将请求交给线程池，并当请求完成后通过回调的方式，把返回的数据设置到界面或者处理，这样就能避免用户界面无响应的情况。

使用线程池也可提高程序并行处理的性能，将耗时任务通过异步执行的方式提高程序效率。



## 设计一个线程池的注意事项

当我们在设计一个组件或一个类的时候，大部分都是在设计：

1. 接口设计
2. 数据结构设计

线程池也不例外，在上面提到，线程池需要管理线程并接收处理任务，最后通过回调的形式返回数据。

**线程池的接口设计**
对于线程池本身的接口，包含线程池创建、线程池销毁、提交任务。其中如线程池创建需要带上线程数量参数，提交任务需要带上函数指针和函数参数。

**线程池的大小应该为多少？**
线程池的大小值线程数量，无论在什么情况，线程数量都不是越多越好，线程池的大小都是相对的。这是因为线程数量过多会增加上下文切换的次数，导致整体系统性能降低,，且系统为了使每个线程获取公平的调度，花费更多时间管理和调度线程。对于cpu密集型任务，此时任务需要cpu尽可能长时间处理数据，那么此时线程池大小应该设置得与核心数量相当且略高。对于io密集型任务，此时任务需要等待io操作完成，cpu并没有将算力拿去处理任务，因此可以将线程池的大小设置得相对高。

**线程池的线程应该通过什么数据结构管理？**
常见的数据结构有数组、链表、队列、栈、哈希、红黑树等，对于线程池来说，线程的创建和销毁并不频繁，因为线程池的核心就是复用线程，因此涉及到的时间复杂度要求并不高，使用链表即可。

**线程池的任务应该使用什么数据结构？**
对于任务，始终有先来先处理的规则，符合这一个逻辑正好就是队列，队列先进先出。

**什么是惊群？**
当线程池中的线程都在等待获取任务，通用逻辑如下

```c++
Task* get_task(){
    Task* task = nullptr;
    while(!(task = popTask())){	
        //获取任务失败，线程进入等待状态
        std::unique_lock<std::mutex> lock(m_mutx);
        m_condvar.wait(lock);
        //在wait后，被notify_all唤醒，并抢到了互斥量
    }
}
```

上面代码可以用在线程池中，线程获取任务，但是需要注意，如果所有线程都使用一个条件变量，当调用notify_all后，所有的线程都会被唤醒争抢同一个互斥量，应该改为notify_one避免惊群。



## 使用线程池性能就一定好？

是否使用线程池以及如何设计线程池，需要根据具体的应用场景和需求来决定。在某些情况下，线程池可以显著提高性能；而在其他情况下，它可能不会带来预期的性能提升，甚至可能降低性能。在实际应用中，通常需要通过性能测试和分析来确定是否使用线程池以及如何优化线程池的配置。