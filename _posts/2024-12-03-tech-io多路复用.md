---
title: "io介绍"
subtitle: " "
layout: post
author: "Tidcl"
header-style: text
hidden: false
plchart: true
tags:
  - Linux
  - IO
  - IO多路复用

---



## io是什么？

io是input/output的简写，输入/输出本质上就是在描述数据传输，因此对于一个io一定存在输入方和输出方，即一个io涉及到两个设备的数据传输。
带入到计算机中，鼠标键盘和显示器就是我们经常接触的io，用户使用鼠标键盘输入操作命令，显示器对用户输出画面。再从编程的视角理解io，我们常用的文件io、网络io，其本质也是操作系统与磁盘和网卡的数据传输。很多人在接触io都是编程时，通过opne打开文件fd，通过socket创建网络socket，这表面上都是应用程序在操作磁盘和网卡，事实却是这些io操纵真正发生的地方是操作系统。
为什么说文件io和网络io是操作系统跟磁盘和网卡传输数据，而不是应用程序跟磁盘和网卡传输数据？当应用程序操作io时，进行的io操作如read、write只是向操作系统提交一个io调用，并不是程序真正进行操作io，不然也不会有内核态和用户态区分。这类需要与硬件交互的调用基本上都是由操作系统代完成的，当然也有如uio技术可以让程序直接操作硬件，说到底就如虚拟内存一样，应用程序只需要执行操作系统让它能看到的和使用的资源就好，当应用程序需要使用硬件资源时，操作系统会代替应用程序完成，最终将结果返回给应用程序。



### 阻塞和非阻塞io

提到io，阻塞和非阻塞是绕不开的话题，读一个阻塞io，如果io没有数据，程序会卡住等待数据到来，当io有数据后，程序继续执行。读一个非阻塞io，如果io没有数据，程序并不会卡住等待数据，而是返回0，表示这次从io中读到了io个数据。写io相反，如果操作系统中缓冲区满了，此时写入也会卡住等待。但如果是非阻塞io，此时会立刻返回写入为0.



### 同步和异步io

对阻塞和非阻塞有概念之后，同步和异步也是io的重点。
阻塞和非阻塞io都是同步io，同步io和异步io的最大区别就是当进行io调用时，数据是否立刻返回还是回调返回。上面提到的阻塞io和非阻塞io都是同步，即使非阻塞io返回0那也是返回了数据对吧。
异步io平时接触的比较少，iocp、iouring这俩都是异步io，异步io操作都是将io事件进行提交。比如要读取某个网络fd上的read事件，应用程序就需要向异步io进行read事件的注册，当异步io把read事件完成并返回时，应用程序才会收到数据。
比较直观的说法就是，应用程序使用异步io是被动传输数据，同步io是主动传输数据，正因为是被动，io管理和操作都是异步io组件在操作，可以天然实现io多路复用，即可以在一个线程中实现多个io操纵。

**同步操作**

read、recv、write、send 这四个api都是同步的，当用户应用程序调用api时，内核进行操作。当api返回时，这个“操作”就结束了，这样的调用叫同步。阻塞和非阻塞表示调用api时是否等待内核完成，非阻塞与同步，“操作”也是立刻就结束了，阻塞也是如此“操作”立刻就完成了。



## io多路复用

IO多路复用是一种在单个线程中管理多个输入/输出通道的技术。它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。常见的IO多路复用机制包括select、poll和epoll。

### 为什么要有io多路复用？

传统网络io操作，以服务器为例。创建socket，绑定ip和port，进行监听，最终使用accept获取客户端连接。获取客户端fd后，在while中对客户端进行读写操作，如此以来一个线程只能获取一个客户端连接，且只能读写一个客户端。如今的网络模型已经多种多样，像nginx、mysql、redis、mongodb都对于自己的使用场景设计了对应的网络模型，如果没有io多路复用只能一线程一连接且阻塞处理，很容易出现性能瓶颈。

io多路复用提高了并发能力，使得单线程也能进行多io处理。

### select

window和linux都可用，且mysql选择select作为自己的io复用技术。
select底层通过bitmap来监控io，比如一个char 8位，如果以一个char作为bitmap则可以同时监控8个io，不同位就代表不同io。select通过fd_set的方式组织io，将不同的fd_set放入select，select底层通过循环判断io是否有事件，如果有事件设置fd_set中对应io的位为1，返回到应用程序使用FD_ISSET判断fd_set对应io位是否为1。

select使用bitmap，又因为bitemap的长度不能不能无限长，select最多只能监控1024个io，因此select的并发低。

### poll

window和linux都可用，大号版select。
poll只有一个api：int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)
poll底部通过数组的方式管理io，应用程序每次将io数组拷贝给poll，poll系统调用采用轮询方式获取socket事件信息，一次poll调用需完成整个poll_list链表轮询工作，一定程度上解决了select因为bitmap长度有限导致的并发度降低。也因为数组，io变多拷贝到内核的数据也会变多，最终性能下降。

poll比起select使用简单，没有从根本解决select的并发问题。

### epoll

linux系统支持。
网上对epoll的介绍有很多，这里只提部分epoll的东西。
epoll底层使用红黑树实现，为什么不用哈希、链表、跳表数据结构，主要是因为红黑树在增删改查时间都相对稳定。hash无论是通过链表法、开放地址法都无法解决当连接数量过多时，因为哈希最优时间是O(1)但是最坏是O(n)，链表O(n)，跳表也会因为节点变多导致层数增加带来性能退化。

epoll比起select和poll，epoll减少io信息的拷贝量。select拷贝fd_set位数组，poll拷贝数组，epoll的接口都是在更新红黑树，每次都是一个一个往红黑树上添加节点。且epoll返回就绪io数组时，并不遍历整个红黑树，只需要从就绪队列取出已准备好的节点即可。